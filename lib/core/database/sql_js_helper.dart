/// SQL.js Database Helper for Web Platform
///
/// This file provides a sqflite-compatible database interface for web platforms
/// using sql.js (WASM-based SQLite). It is conditionally imported when running
/// on web, while mobile platforms use sqflite directly.
///
/// Architecture:
/// - Mobile: Uses sqflite (native SQLite)
/// - Web: Uses sql.js (WASM SQLite) via this helper
///
/// The API matches sqflite exactly to ensure zero code changes in services.
///
/// Implementation Status:
/// - [x] Task 2.2: WASM loading (sqflite_common_ffi_web handles WASM automatically)
/// - [x] Task 2.3: IndexedDB persistence (sqflite_common_ffi_web handles persistence automatically)
/// - [x] Task 2.4: Query implementation
/// - [x] Task 2.5: Insert/Update/Delete implementation âœ… PHASE 1 COMPLETE
library sql_js_helper;

import 'dart:async';
import 'dart:typed_data';
import 'package:sqflite_common/sqlite_api.dart' hide ConflictAlgorithm;
import 'package:sqflite_common/sqlite_api.dart' as sqflite show ConflictAlgorithm;
import 'package:sqflite_common_ffi_web/sqflite_ffi_web.dart';

/// Web-compatible SQLite implementation using sql.js (WASM)
///
/// This class provides a sqflite-compatible API for web platforms using sql.js.
/// On mobile platforms, use sqflite directly via DatabaseHelper.
///
/// Features:
/// - Full SQLite support via WASM
/// - IndexedDB persistence across sessions
/// - sqflite-compatible query API
/// - Lazy singleton pattern
///
/// Usage:
/// ```dart
/// final db = await SqlJsHelper.database;
/// final results = await db.query('bible_verses', limit: 10);
/// ```
class SqlJsHelper {
  // Singleton pattern
  static SqlJsDatabase? _database;
  static bool _initialized = false;

  /// Get the singleton database instance
  ///
  /// Implements lazy singleton pattern with WASM initialization.
  /// The database is initialized only on first access and cached for subsequent calls.
  static Future<SqlJsDatabase> get database async {
    if (_database != null) return _database!;

    _database = await _openDatabase();
    return _database!;
  }

  /// Initialize sql.js WASM module
  ///
  /// Loads the SQLite WASM module via sqflite_common_ffi_web.
  /// This sets up the database factory for web platform.
  ///
  /// The WASM files (sqlite3.wasm, sqflite_sw.js) should be generated by running:
  /// `dart run sqflite_common_ffi_web:setup`
  ///
  /// Throws [DatabaseException] if initialization fails.
  static Future<void> _initialize() async {
    if (_initialized) return;

    try {
      // sqflite_common_ffi_web handles WASM loading automatically
      // when using databaseFactoryFfiWeb
      // No explicit WASM initialization needed - it's handled by the factory
      _initialized = true;
    } catch (e) {
      throw DatabaseException(
        'Failed to initialize SQLite WASM module: $e',
      );
    }
  }

  /// Open or create database
  ///
  /// Creates or loads the database using sqflite_common_ffi_web factory.
  /// The database is automatically persisted to IndexedDB by the factory.
  ///
  /// Database path is set to 'everyday_christian.db' for web platform.
  /// IndexedDB persistence is handled automatically by sqflite_common_ffi_web.
  ///
  /// Returns [SqlJsDatabase] instance wrapping the sqflite Database.
  /// Throws [DatabaseException] if database cannot be opened.
  static Future<SqlJsDatabase> _openDatabase() async {
    await _initialize();

    try {
      // Use sqflite_common_ffi_web factory for web platform
      // This automatically handles:
      // - WASM loading
      // - IndexedDB persistence
      // - Cross-tab safety via shared workers
      final db = await databaseFactoryFfiWeb.openDatabase(
        'everyday_christian.db',
        options: OpenDatabaseOptions(
          version: 1,
          // onCreate, onUpgrade etc. will be added when migrating from mobile
        ),
      );

      return SqlJsDatabase._internal(db);
    } catch (e) {
      throw DatabaseException(
        'Failed to open database: $e',
      );
    }
  }

  /// Save database to IndexedDB
  ///
  /// Note: sqflite_common_ffi_web automatically handles persistence to IndexedDB.
  /// This method is kept for API compatibility but is not needed for normal operations.
  /// The database is automatically saved after each transaction.
  // ignore: unused_element
  static Future<void> _saveToIndexedDB(SqlJsDatabase db) async {
    // Auto-handled by sqflite_common_ffi_web
    // No explicit save needed - persistence happens automatically
  }

  /// Load database from IndexedDB
  ///
  /// Note: sqflite_common_ffi_web automatically handles loading from IndexedDB.
  /// This method is kept for API compatibility but is not needed for normal operations.
  /// The database is automatically loaded when opened via databaseFactoryFfiWeb.
  // ignore: unused_element
  static Future<Uint8List?> _loadFromIndexedDB() async {
    // Auto-handled by sqflite_common_ffi_web
    // No explicit load needed - data is restored automatically on openDatabase
    return null;
  }

  /// Close database and clean up
  ///
  /// Closes the database connection and releases resources.
  /// After calling this, a new instance will be created on next access to [database].
  static Future<void> close() async {
    if (_database != null) {
      await _database!._database?.close();
      _database = null;
      _initialized = false;
    }
  }
}

/// Web-compatible SQLite database wrapper
///
/// Wraps the sqflite_common Database/Transaction instance to provide a consistent API
/// across mobile (native sqflite) and web (WASM-based sqflite_common_ffi_web).
///
/// This class is designed to be API-compatible with sqflite's Database class,
/// allowing the same code to work on both platforms via conditional imports.
///
/// Note: Uses DatabaseExecutor to support both Database and Transaction objects.
class SqlJsDatabase {
  /// The underlying sqflite_common DatabaseExecutor instance
  /// (supports both Database and Transaction)
  final DatabaseExecutor _db;

  /// The actual Database instance (null if this is a transaction wrapper)
  final Database? _database;

  /// Internal constructor - use SqlJsHelper.database to get instance
  SqlJsDatabase._internal(DatabaseExecutor db)
      : _db = db,
        _database = db is Database ? db : null;

  /// Get the underlying database for advanced operations
  ///
  /// This exposes the sqflite_common DatabaseExecutor for operations not covered
  /// by the instance methods.
  DatabaseExecutor get rawDatabase => _db;

  // Instance methods (moved from extension for dynamic type compatibility)
  /// Query database with optional filters
  ///
  /// Returns a list of rows matching the query criteria.
  ///
  /// Parameters:
  /// - [table]: Table name to query
  /// - [distinct]: Return distinct rows only
  /// - [columns]: Columns to select (null = all columns)
  /// - [where]: WHERE clause (use ? for placeholders)
  /// - [whereArgs]: Arguments for WHERE clause placeholders
  /// - [groupBy]: GROUP BY clause
  /// - [having]: HAVING clause
  /// - [orderBy]: ORDER BY clause
  /// - [limit]: Maximum rows to return
  /// - [offset]: Number of rows to skip
  ///
  /// Example:
  /// ```dart
  /// final verses = await db.query(
  ///   'bible_verses',
  ///   where: 'book = ?',
  ///   whereArgs: ['John'],
  ///   limit: 10,
  /// );
  /// ```
  ///
  /// Throws [DatabaseException] if query fails.
  Future<List<Map<String, dynamic>>> query(
    String table, {
    bool? distinct,
    List<String>? columns,
    String? where,
    List<Object?>? whereArgs,
    String? groupBy,
    String? having,
    String? orderBy,
    int? limit,
    int? offset,
  }) async {
    try {
      return await _db.query(
        table,
        distinct: distinct,
        columns: columns,
        where: where,
        whereArgs: whereArgs,
        groupBy: groupBy,
        having: having,
        orderBy: orderBy,
        limit: limit,
        offset: offset,
      );
    } catch (e) {
      throw DatabaseException(
        'Query failed on table $table: $e',
        sql: 'SELECT ${columns?.join(", ") ?? "*"} FROM $table${where != null ? " WHERE $where" : ""}',
        sqlArguments: whereArgs,
      );
    }
  }

  /// Insert a row into table
  ///
  /// Returns the row ID of the inserted row.
  ///
  /// Parameters:
  /// - [table]: Table name
  /// - [values]: Column-value pairs to insert
  /// - [conflictAlgorithm]: How to handle conflicts (REPLACE, IGNORE, etc.)
  ///
  /// Example:
  /// ```dart
  /// final id = await db.insert(
  ///   'prayer_requests',
  ///   {'title': 'Prayer for healing', 'category': 'cat_health'},
  ///   conflictAlgorithm: ConflictAlgorithm.replace,
  /// );
  /// ```
  ///
  /// Throws [DatabaseException] if insert fails.
  Future<int> insert(
    String table,
    Map<String, Object?> values, {
    String? nullColumnHack,
    ConflictAlgorithm? conflictAlgorithm,
  }) async {
    try {
      return await _db.insert(
        table,
        values,
        nullColumnHack: nullColumnHack,
        conflictAlgorithm: _mapConflictAlgorithm(conflictAlgorithm),
      );
    } catch (e) {
      throw DatabaseException(
        'Insert failed on table $table: $e',
        sql: 'INSERT INTO $table',
        sqlArguments: values.values.toList(),
      );
    }
  }

  /// Update rows in table
  ///
  /// Returns the number of rows affected.
  ///
  /// Parameters:
  /// - [table]: Table name
  /// - [values]: Column-value pairs to update
  /// - [where]: WHERE clause (use ? for placeholders)
  /// - [whereArgs]: Arguments for WHERE clause placeholders
  ///
  /// Example:
  /// ```dart
  /// final count = await db.update(
  ///   'prayer_requests',
  ///   {'is_answered': 1, 'date_answered': DateTime.now().millisecondsSinceEpoch},
  ///   where: 'id = ?',
  ///   whereArgs: ['prayer_123'],
  /// );
  /// ```
  ///
  /// Throws [DatabaseException] if update fails.
  Future<int> update(
    String table,
    Map<String, Object?> values, {
    String? where,
    List<Object?>? whereArgs,
    ConflictAlgorithm? conflictAlgorithm,
  }) async {
    try {
      return await _db.update(
        table,
        values,
        where: where,
        whereArgs: whereArgs,
        conflictAlgorithm: _mapConflictAlgorithm(conflictAlgorithm),
      );
    } catch (e) {
      throw DatabaseException(
        'Update failed on table $table: $e',
        sql: 'UPDATE $table SET ... WHERE $where',
        sqlArguments: whereArgs,
      );
    }
  }

  /// Delete rows from table
  ///
  /// Returns the number of rows deleted.
  ///
  /// Parameters:
  /// - [table]: Table name
  /// - [where]: WHERE clause (use ? for placeholders)
  /// - [whereArgs]: Arguments for WHERE clause placeholders
  ///
  /// Example:
  /// ```dart
  /// final count = await db.delete(
  ///   'prayer_requests',
  ///   where: 'id = ?',
  ///   whereArgs: ['prayer_123'],
  /// );
  /// ```
  ///
  /// Throws [DatabaseException] if delete fails.
  Future<int> delete(
    String table, {
    String? where,
    List<Object?>? whereArgs,
  }) async {
    try {
      return await _db.delete(
        table,
        where: where,
        whereArgs: whereArgs,
      );
    } catch (e) {
      throw DatabaseException(
        'Delete failed on table $table: $e',
        sql: 'DELETE FROM $table WHERE $where',
        sqlArguments: whereArgs,
      );
    }
  }

  /// Execute raw SQL statement
  ///
  /// Use for CREATE TABLE, CREATE INDEX, etc.
  ///
  /// Example:
  /// ```dart
  /// await db.execute('CREATE INDEX idx_test ON test_table(column)');
  /// ```
  ///
  /// Throws [DatabaseException] if execution fails.
  Future<void> execute(String sql, [List<Object?>? arguments]) async {
    try {
      await _db.execute(sql, arguments);
    } catch (e) {
      throw DatabaseException(
        'Execute failed: $e',
        sql: sql,
        sqlArguments: arguments,
      );
    }
  }

  /// Execute transaction
  ///
  /// All operations in the callback are atomic.
  ///
  /// Example:
  /// ```dart
  /// await db.transaction((txn) async {
  ///   await txn.insert('table1', {...});
  ///   await txn.insert('table2', {...});
  /// });
  /// ```
  ///
  /// Throws [DatabaseException] if transaction fails.
  Future<T> transaction<T>(
    Future<T> Function(SqlJsDatabase txn) action,
  ) async {
    // Transaction only works on Database, not on Transaction objects
    if (_database == null) {
      throw const DatabaseException(
        'Transaction called on non-Database executor (possibly nested transaction)',
      );
    }

    try {
      return await _database!.transaction((txn) async {
        // Wrap the sqflite transaction in our SqlJsDatabase wrapper
        final wrappedTxn = SqlJsDatabase._internal(txn);
        return await action(wrappedTxn);
      });
    } catch (e) {
      throw DatabaseException(
        'Transaction failed: $e',
      );
    }
  }

  /// Execute raw SQL query
  ///
  /// Use for custom queries not covered by query/insert/update/delete.
  ///
  /// Example:
  /// ```dart
  /// final results = await db.rawQuery(
  ///   'SELECT * FROM bible_verses WHERE book = ? LIMIT ?',
  ///   ['John', 10],
  /// );
  /// ```
  ///
  /// Throws [DatabaseException] if query fails.
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? arguments,
  ]) async {
    try {
      return await _db.rawQuery(sql, arguments);
    } catch (e) {
      throw DatabaseException(
        'Raw query failed: $e',
        sql: sql,
        sqlArguments: arguments,
      );
    }
  }

  /// Map our ConflictAlgorithm enum to sqflite's ConflictAlgorithm enum
  ///
  /// This helper function converts between our custom ConflictAlgorithm enum
  /// and the sqflite_common library's ConflictAlgorithm enum.
  ///
  /// Returns null if input is null (allows sqflite to use default behavior).
  sqflite.ConflictAlgorithm? _mapConflictAlgorithm(ConflictAlgorithm? algorithm) {
  if (algorithm == null) return null;

  switch (algorithm) {
    case ConflictAlgorithm.rollback:
      return sqflite.ConflictAlgorithm.rollback;
    case ConflictAlgorithm.abort:
      return sqflite.ConflictAlgorithm.abort;
    case ConflictAlgorithm.fail:
      return sqflite.ConflictAlgorithm.fail;
    case ConflictAlgorithm.ignore:
      return sqflite.ConflictAlgorithm.ignore;
    case ConflictAlgorithm.replace:
      return sqflite.ConflictAlgorithm.replace;
  }
  }
}

/// Conflict resolution algorithms for INSERT/UPDATE operations
///
/// Matches sqflite's ConflictAlgorithm enum.
enum ConflictAlgorithm {
  /// When a constraint violation occurs, roll back the current transaction
  rollback,

  /// When a constraint violation occurs, abort and throw error
  abort,

  /// When a constraint violation occurs, skip the operation
  fail,

  /// When a constraint violation occurs, silently ignore
  ignore,

  /// When a constraint violation occurs, replace the existing row
  replace,
}

/// Custom exception for database errors
///
/// Matches sqflite's DatabaseException for API compatibility.
class DatabaseException implements Exception {
  /// Error message
  final String message;

  /// SQL statement that caused the error (if available)
  final String? sql;

  /// SQL arguments that caused the error (if available)
  final List<Object?>? sqlArguments;

  /// Creates a database exception
  const DatabaseException(
    this.message, {
    this.sql,
    this.sqlArguments,
  });

  @override
  String toString() {
    final buffer = StringBuffer('DatabaseException: $message');
    if (sql != null) {
      buffer.write('\nSQL: $sql');
    }
    if (sqlArguments != null && sqlArguments!.isNotEmpty) {
      buffer.write('\nArguments: $sqlArguments');
    }
    return buffer.toString();
  }
}
